---
title: "A Manchester case study"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{manchester}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

```{r setup}
library(tidyverse)
library(osmactive)
library(tmap)
library(sf)
library(osmactive)
library(stplanr)
library(pct)
```

This vignette demonstrates how to generate bike bus routes to Manley Park Primary School in Manchester.
We chose this school because an existing bike bus was set up at the school in 2025.
As a contrast from the applications in Lisbon, Portugal, this shows that the bicischools package can be used to support bike buses internationally.

First we define a catchment area for the school, based on local knowledge of where students live.

```{r}
## code to prepare `example_school_mcr` dataset goes here


# Rough catchment for Manley Park Primary School
zones = zonebuilder::zb_zone(
    "Whalley Range Sure Start Centre",
    n_circles = 2,
    distance = 0.5
)

study_area = sf::st_union(zones)

mapview::mapview(zones)
```

We get speed limits for the local road network.

```{r}
osm_data = osmactive::get_travel_network(
    place = study_area,
    boundary = study_area,
    boundary_type = "clipsrc"
)

osm_drive = osmactive::get_driving_network(osm_data)

mapview::mapview(osm_drive, zcol = "maxspeed")
```

We can now estimate cycle Level of Service across the local road network, based on speed limits and estimated traffic flows.

```{r}
# Get Level of Service

cycle_net = osmactive::get_cycling_network(osm_data)
cycle_net = distance_to_road(cycle_net, osm_drive)
cycle_net = classify_cycle_infrastructure(cycle_net, include_mixed_traffic = TRUE)

cycle_net = estimate_traffic(cycle_net)
cycle_net$AADT = npt_to_cbd_aadt_numeric(cycle_net$assumed_volume)
cycle_net = level_of_service(cycle_net)
plot(cycle_net["Level of Service"])
mapview::mapview(cycle_net["Level of Service"])
```

After some data cleaning, student home locations are randomly chosen within the defined school catchment.

```{r}
names(cycle_net)
cycle_net_cols_to_keep = c(
  "osm_id",
  "name",
  "highway",
  "maxspeed",
  "bicycle",
  "cycleway_chars",
  "lanes",
  "segregated",
  "surface"
)
cycle_net = cycle_net |> 
  select(all_of(cycle_net_cols_to_keep))

# usethis::use_data(example_school_mcr, overwrite = TRUE)

# Create random home locations within the zonebuilder area
cycle_net_joined = sf::st_union(cycle_net)
points = sf::st_sample(cycle_net_joined, size = 1000)

points = st_as_sf(points)
points = points |> 
  filter(!st_is_empty(points))

centre = sf::st_centroid(zones)[1,]

tm_shape(cycle_net_joined) + tm_lines() +
  tm_shape(points) + tm_dots(size = 1) +
  tm_shape(centre) + tm_dots(size = 2)
```

We extract the number of students at the school from a national schools dataset.

```{r}
# Get number of students
# school_manc = osmextract::oe_get("College Road, Whalley Range, Manchester, M16 0AA")
# number of pupils = 430

school_name = "Manley Park Primary School"
xlfile = "data-raw/edubasealldata20250724.xlsx"
extract_students = function(school_name) {
  x = readxl::read_xlsx(xlfile)
  x = x |> filter(EstablishmentName == school_name)
  number_of_pupils = x$NumberOfPupils
}
n = extract_students(school_name)
```

Desire lines represent trips from home to school.
<!-- These need fixing -->

```{r}
# Create desire lines
od = points |>
  mutate(d = centre$geometry)

od$geometry =
  Map(st_union, od$x, od$d) |>
  st_as_sfc(crs = st_crs(od)) |>
  st_cast("LINESTRING")

od = od |>
  mutate(
    desire_line_length = units::drop_units(st_length(geometry))
  )
od = od |> 
  filter(desire_line_length < 5000)

od = od |> 
  mutate(trips = nrow(od)/n)

# Fix the geometry
od_standard = od |> 
  st_drop_geometry() |> 
  mutate(id = row_number()) |> 
  select(id, trips, desire_line_length, geometry)
od_standard = st_as_sf(od_standard)

# The desire lines still look strange!
tm_shape(od_standard) + tm_lines()
```

We convert the desire lines into routes

```{r}
# Generate routes to school from these points
# Create routes

plan = "quietest"

routes_plan = stplanr::route(
  l = od_standard,
  route_fun = cyclestreets::journey,
  plan = plan
)
tm_shape(routes_plan) + tm_lines("trips")

routes = routes_plan |>
  group_by(route_number) |>
  mutate(route_hilliness = weighted.mean(gradient_smooth, distances)) |>
  ungroup()
class(routes$route_number) = "character"
class(routes$length) = "numeric"
class(routes$quietness) = "numeric"
assign("routes_all", routes)
routes = routes |>
  filter(length < 5000)
saveRDS(routes, paste0("./data-raw/routes-manchester.Rds"))

route_summaries = routes_all |>
  group_by(route_number) |>
  summarise(
    trips = mean(trips),
    length = mean(length),
    desire_line_length = mean(desire_line_length)
  )
assign("route_summaries_all", route_summaries)
```

Using the PCT Go Dutch scenario we estimate potential cycle uptake under Dutch-style cycling levels.

We then convert the routes to school into a route network.

```{r}
# Rnet and PCT uptake
routes_pct = routes |>
  group_by(route_number) |>
  mutate(
    pcycle_godutch = pct::uptake_pct_godutch_school2(
      case_when(length > 30000 ~ 30000, TRUE ~ length),
      route_hilliness
    ),
    bicycle_godutch = pcycle_godutch * trips
  )
rnet_raw = routes_pct |>
  overline(
    attrib = c(
      "trips",
      "bicycle_godutch",
      "quietness",
      "gradient_smooth"
    ),
    fun = list(sum = sum, mean = mean)
  )
rnet = rnet_raw |>
  transmute(
    trips = trips_sum,
    bicycle_godutch = bicycle_godutch_sum,
    quietness = round(quietness_mean),
    gradient = round(gradient_smooth_mean * 100)
  )

# tm_shape(rnet_quietest) +
#   tm_lines(
#     "bicycle_godutch",
#     palette = "viridis",
#     lwd = 2,
#     breaks = c(0, 5, 10, 100)
#   ) +
#   tm_shape(centroids_5km) +
#   tm_bubbles("trips") +
#   tm_shape(school) +
#   tm_bubbles(col = "green")

quietness_breaks = c(0, 25, 50, 75, 100)
pal = c('#882255', '#CC6677', '#44AA99', '#117733')

route_summaries = routes_pct |>
  group_by(id, route_number, trips, bicycle_godutch, length) |>
  summarise() |>
  ungroup()

# First function by Juan 
ordered_routes = cycle_bus_routes(
  routes = routes_pct,
  rnet = rnet
  )

buffer = 10
attribute_trips = "bicycle_godutch"
min_trips = 3

rnet_plan = get(paste0("rnet_", plan))
routes = get(paste0("route_summaries_", plan))

rnet_subset = rnet[rnet[[attribute_trips]] > min_trips, ]
rnet_subset$length = sf::st_length(rnet_subset) |>
  as.numeric()
rnet_union = sf::st_union(rnet_subset)
rnet_buffer = geo_buffer(rnet_union, dist = buffer)
routes_crop = sf::st_intersection(routes, rnet_buffer)

ordered_routes = ordered_routes
join = sf::st_join(routes_crop, ordered_routes, join = st_equals)
route_stats = join |>
  mutate(
    full_length = length.x,
    bike_bus_length = length.y,
    dist_to_bike_bus = length.x - length.y
  ) |>
  select(-length.x, -length.y)
assign(paste0("route_stats_", plan), route_stats)


```

